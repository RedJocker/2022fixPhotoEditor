<h2>Description</h2>

<p>In this stage, we will add another feature — the <strong>contrast filter</strong>.</p>

<p>When the contrast is at the minimum, it means that all pixels have the same brightness value. Maximum contrast infers that the difference between the darkest and brightest pixel is at the maximum: one is <code>0</code>, and the other is <code>255</code>.</p>

<p>To adjust contrast, we must be able to highlight/play down the brightness of each pixel taking into consideration the average image brightness. The average brightness is calculated for the whole image, that is, there is only one average brightness for one image. The catch is, both filters should affect each other and work at the same time.</p>

<p>Adding another filter means another slider that will change the contrast value.</p>

<p>More on contrast can be found in the article <a href="https://theailearner.com/2019/01/30/what-is-contrast-in-image-processing/" rel="noopener noreferrer nofollow">What is Contrast in Image Processing?</a> by TheAILearner.</p>

<h2>Objectives</h2>

<p>Add the following components to the application layout:</p>

<ul>
	<li>Another <code>Slider</code> widget for specifying the photo contrast. Set its <code>id</code> attribute as <code>slContrast</code>; the values may vary from <code>-250</code> to <code>250</code> with the step size of <code>10</code> and the initial value of <code>0</code>;</li>
	<li>The contrast filter values are calculated in the following way:</li>
</ul>

<p><span class="math-tex">\[red = alpha \times (Red - avgBright) + avgBright \\ green = alpha \times (Green - avgBright) + avgBright \\ blue = alpha \times (Blue - avgBright) + avgBright\]</span></p>

<p>where:</p>

<p><span class="math-tex">\[alpha = \frac{(255 + contrast)}{(255 - contrast)}\]</span>and:</p>

<p><span class="math-tex">\[avgBright = the\ average\ image\ brightness\]</span></p>

<p>Contrast is the current state of the slider value.</p>

<ul>
	<li>While calculating avgBright first accumulate all pixel brightness values then do the division instead of having partials of avgBright.
		This is to avoid truncation problems with integer division on the partials.
		You can use <code>Long</code> on the accumulator to avoid overflow issues,
		but after the division you can use <code>Int</code> since the value is expected to be bound up to 255
	</li>
	<li>Use <code>Double</code> for contrast alpha</li>
	<li>Order of filters matters. To pass the tests, filters must be applied in the following order: <code>brightnessFilter</code> -&gt; <code>contrastFilter</code>;</li>
	<li>Color values should not get out of bounds: <code>[0, 255]</code>;</li>
	<li>The <code>avgBrightness</code> should be calculated after brightness filter has already been applied.</li>
</ul>

<h2>Example</h2>

<p><strong>Example 1:</strong> <em>the contrast slider &amp; the result</em></p>

<p><img alt="" height="520" name="Android Emulator - Pixel_3a_API_30_x86_5554 2021-12-05 12-12-03.gif" src="https://ucarecdn.com/024b37ab-7c1d-410d-be19-8031fa1e4835/" width="270"></p>